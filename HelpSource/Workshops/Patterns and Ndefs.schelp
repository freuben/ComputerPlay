TITLE:: Patterns and Ndefs
summary:: Computer.play(Music, Creativity & Code)
categories:: Tutorials/ComputerDotPlay
related:: Computer, Workshops/Playing with UGens, Study Guides/Digital Synthesis

section::Patterns

strong::Patterns::, like routines, are very useful for scheduling different events in SC. They are good for specifying sequences of different actions that might happen either together or after each other. You can specify many events over time using Patterns. They are convenient for dealing with multiple timings and event repetitions. They are often used to specify musical patterns, whether they are rhythmic patterns or a sequence of pitches.

Note::Patterns can be very convenient for Generative Music and Algorithmic Composition!::

Patterns use strong::Streams::: a class that represents a sequence of values that are obtained with the strong::next:: message.

Patterns are an easy way to make multiple streams from a single specification. It is like cloning the patterns or to switch metaphors, using a cookie cutter to produce many similar streams.

Note::Streams produce one value each time they receive a strong::next:: message.::

Patterns are a way of specifying what a stream should do.

There are many types of Patterns, some of which, we will explore today.

subsection::Pseq

code::Pseq:: is a Pattern that produces a sequence of events that can be repeated a specified amount of times.

code::Pseq(list, repeats)::

loops through a list, repeats a number of times.

code::
(
a = Pseq([60,64,67,69], 2).asStream;
8.do({a.next.postln});
)
::

Previously we have seen how we can schedule a sequence of events through a strong::Routine::. This can be simplified using a code::Pattern::.

code::
//synthdef
(
	SynthDef( "perkysine", {
	| freq=400, amp=1|
	var osc;
	osc = SinOsc.ar( [freq,freq+0.05.rand] ) * EnvGen.ar(
	Env.perc, doneAction: 2) * 0.2;
	Out.ar(0,osc*amp);
	}).store;
)
//routine
(
	p = {
		2.do{
		Synth(\perkysine, [\freq,60.postln.midicps]);
		0.2.yield;
		Synth(\perkysine, [\freq,60.postln.midicps]);
		0.2.yield;
		Synth(\perkysine, [\freq,67.postln.midicps]);
		0.2.yield;
		Synth(\perkysine, [\freq,69.postln.midicps]);
		0.2.yield;
		}
	}.fork;
)
//pattern
Pbind(\instrument, \perkysine, \midinote, Pseq([60,60,67,69],2), \dur, 0.2, \legato, 1.0).play
//more complex (minimalist) example::
(
~notes1 = [0,2,4,5,7,9,11];
~notes2 = [~notes1[0], ~notes1[2], ~notes1[4]];
~par1 = Pbind(\instrument, \perkysine, \degree, Pseq(~notes1.scramble,inf), \dur, 0.2, \legato, 0.5, \amp, 0.7);
~par2 = Pbind(\degree, Pseq(~notes2,inf), \ctranspose, -12, \dur, 0.3, \legato, 0.8);
~par3 = Pbind(\degree, Pseq((~notes2+0.2).reverse,inf), \ctranspose, -12, \dur, 0.4, \legato, 0.3);
Ppar([~par1, ~par2, ~par3]).play;
)
::

subsection::Pbind

code::Pbind:: is a pattern "player". It takes a variety of patterns and matches them to Events. These events produce sounds and modify different arguments and behaviour.

code::Pbind:: is a class that lets you match properties of a sound event with values
list::
##e.g. freq or midinote to create frequencies
##dur for duration
##amp  for amplitude
 ##instrument for instrument
::
You can find more information on the types of useful Events available link::Workshops/Patterns, Effects and Ndefs#Events and Patterns#below::.

To play default values of code::Pbind:::
code::
a = Pbind.new.play   // if no additional arguments, new method must explicitedly be used
a.stop
::

to change duration:
code::
Pbind(\dur,0.125).play
::
to play a chord:
code::
Pbind(\midinote,[60,64,67,69]).play
::
to play with a different instrument:

code::SynthDef:: needs to receive the store message which stores and loads the synthdef but
also adds it to the code::SynthDescLib:: so it can be used with code::Pbind::.
code::
	SynthDescLib.global.read   // prepares a library of SynthDesc objects
	SynthDescLib.global.browse
::
your instrument should use code::doneAction: 2:: to release the code::Synth::.
code::
(
SynthDef(\strum,{
 |freq = 440|
 var trigger, pluck, period, string, out;
     trigger = HPZ1.kr(XLine.kr(1,0,0.01)).abs;
     pluck = PinkNoise.ar(Decay.kr(trigger, 0.05));
     period = freq.reciprocal;
     string = CombL.ar(pluck,period, period, 4);
	out = LPF.ar(string,12000);
	out = LeakDC.ar(out);
	DetectSilence.ar(out, doneAction: 2);
	Out.ar(0,out)
}).store
)

Synth(\strum)

Pbind(\instrument,\strum).play

(
Pbind(\instrument,\strum,
	\midinote,[60,64,67,69]
 ).play
)
//this is SC's default synth
Synth(\default, [\freq, 400]);
//if you don't specify an instrument, Pbind will play default synth
Pbind(\midinote, [60,64,67,69]).play;

::
To play notes in series, you need to use a code::Pattern::

Individual types of patterns will be explained later. For now, they will just be used.

code::Pseq:: iterates over a list of objects:

(list, repeats, offset)

note the additional binding for code::dur:::
code::
(
Pbind(\instrument,\strum,
    \dur, 0.5,
	\midinote,Pseq([60,64,67,69],2)
).play
)
::
A code::Pattern:: returns a code::nil:: after the repetitions are complete.

code::
a = Pseq([1, 3, 400]);
x = a.asStream;
x.next; //evaluate this line several times
::
code::Pbind:: will stop playing when a code::Pattern:: returns a code::nil::.
code::
(
Pbind(\instrument,\strum,
	\dur, 0.5,
	\midinote,Pseq([60,64,67,69])
).play
)
::
To infinitely repeat a code::Pattern::, use code::inf:: for the number of repeats
code::
(
Pbind(\instrument,\strum,
	\dur, 0.5,
	\midinote,Pseq([60,64,67,69],inf)
).play
)
::
Offset gives a starting offset (index) into the list
code::
(
Pbind(\instrument,\strum,
	\dur, 0.5,
	\midinote,Pseq([60,64,67,69],2,3) //list, repeats, offset
).play
)
::
code::Pser::

repeats variable gives the number of values returned rather than the number of cycles


code::
(
Pbind(\instrument,\strum,
	\dur, 0.5,
	\midinote,Pser([60,64,67,69],5)
).play
)
::
code::Prand::

returns one item at random

repeats is the number of items returned before returning a code::nil::

code::
(
var num = 20;
Pbind(\instrument,\strum,
	\dur,Prand([ 0.15,0.25,0.35,0.5],num),
	\midinote,Prand((60..72),num)
).play
)
::
use frequencies instead of midinotes
code::
(
var num = 50;
Pbind(\instrument,\strum,
	\dur,Prand([ 0.15,0.25,0.35,0.5] * 0.5,num),
	\freq,Prand((200,210..600),num)
).play
)
::
code::Pxrand::

returns one item at random but does not repeat twice in a row

code::
(
var num = 50;
Pbind(\instrument,\strum,
	\dur,Pxrand([ 0.15,0.25,0.35,0.5],num),
	\freq,Pxrand((510,520..600),num)
).play
)
::
code::Pshuf::

loops through a list that has been scrambled

the list is repeated without reshuffling


code::
(
Pbind(\instrument,\strum,
	\dur,0.3,
	\midinote,Pshuf((60..65),5)
).play
)
::

code::Prand(list, repeats)::

Repeats for this pattern refers to the number of values returned, not the number of cycles.

code::
(
a = Prand([60,64,67,69],10).asStream;
12.do({a.next.postln})
)

(
p = Prand((48 ..72), inf); // pattern repeats forever: inf
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.1, \amp, 0.1).play
)
::

code::Pwrand(lists, weights, repeats)::

Weighted random choice

weights is a list of probabilities (0-1)
code::
(
a = Pwrand([1,2,3,4],[0.5,0.1,0.2,0.2],20).asStream;
20.do({a.next.postln})
)
::
It seems (empirical observation) that the probabilities do not need to add up to 1, however once the probabilities add up to one, any event with a probability above this threshold seems to be ignored. In the following example, 4 never seems to occur.
code::
(
a = Pwrand([1,2,3,4],[0.5,0.1,0.5,0.2],20).asStream;
20.do({a.next.postln})
)
::
Weighted frequencies:
code::
(
p = Pwrand((60 ..72),[4,3,1,1,0.5,2,1,1,1,1.5,3,1].normalizeSum.postln, inf).asStream;
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.1, \amp, 0.1).play;
)
::

code::normalizeSum:: normalizes the values so the sum of the code::Array:: is 1.

code::Pxrand(lists, repeats)::

returns 1 item at random but does not repeat twice in a row.
code::
(
a = Pxrand([60,61,62],10).asStream;
a.nextN(10)
)
::
The code::nextN:: message when sent to a stream will collect n values in an code::Array::.
code::
(
p  = Pxrand([60,61,62],20);
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.1, \amp, 0.1).play;
)
::

code::Pstutter(n, pattern)::

repeats each element n times
code::
(
a = Pstutter(2, Pseq([1,2,3],inf)).asStream;
a.nextN(10);
)
::
n may also be a pattern so that it can vary each iteration.
code::
(
p = Prand((48 ..72), inf);
d = Pstutter(Prand((1..5),inf), Prand([0.1,0.15,0.2,0.3], inf)); //amount of repetitions varys each iteration
Pbind(\instrument, \perkysine, \midinote, p, \dur, d, \amp, 0.1).play;
)
::
code::Pseries(start, step-size, length)::

generates an arithmetic series
code::
(
p = Pseries(48,2,13).asStream;
p.nextN(13)
)
::
Applied to frequency:
code::
(
p = Pseries(48,2,13).asStream;
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.1, \amp, 0.1).play;
)
::
code::Pgeom(start, multiplication-factor, length)::

generates a geometric series

code::
(
p = Pgeom(1,0.8,20).asStream;
p.nextN(20);
)
::
applied to duration:
code::
(
p =  Pgeom(1,0.8,20).asStream;
Pbind(\instrument, \perkysine, \freq, 440, \dur, p, \amp, 0.1).play;
)
::

subsection::Math with Patterns
Either unary or binary operators can be used with Patterns (or streams)

code::Pattern:: followed by 2 transpositions in one sequence
code::
(
p  = Pseq([60,64,64,65,68,69,71]);
q = Pseq([p,p+7,p+5],inf).asStream;
Pbind(\instrument, \strum, \midinote, q, \dur, 0.1, \amp, 0.1).play;
)
::
Add two patterns

This will transpose each fifth note down two octaves.
code::
(
p = Prand((60 ..72), inf) + Pseq([0,0,0,0,-24], inf);
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.2, \amp, 0.1).play;
)
::

subsection::Filtering streams (and patterns)

Patterns can be filtered with code::Padd, Pmul, Pset,:: and code::Pstretch::.

Streams can also be filtered.

Streams respond to the messages: code::collect, select, reject::

by returning a new stream

collect

collect returns a stream that is modified by some function

code::
(
p = Prand((60 ..72), inf).asStream;
q = p.collect({|item| if (item.even,{item - 24}, {item})});
q.nextN(10);
)
::
This example returns a stream that transposes even note numbers down two octaves:
code::
(
p = Prand((60 ..72), inf).asStream;
q = p.collect({|item| if (item.even,{item - 24}, {item})});
Pbind(\instrument, \perkysine, \midinote, q, \dur, 0.2, \amp, 0.1).play;
)
::
select

creates a stream that passes only items that return true from a supplied function
code::
(
p = Prand((48 ..72), inf).asStream;
q = p.select({|item| item.even});
q.nextN(10);
)
::
selects only the even Midi note numbers:
code::
(
p = Prand((60 ..72), inf).asStream;
q = p.select({|item| item.even});
Pbind(\instrument, \perkysine, \midinote, q, \dur, 0.2, \amp, 0.1).play;
)
::
reject

is similar to select except that it passes only items that return false from a supplied function

reject the even numbers
code::
(
p = Prand((48 ..72), inf).asStream;
q = p.reject({|item| item.even});
q.nextN(10);
)
rejects only the event Midi note numbers
code::
(
p = Prand((60 ..72), inf).asStream;
q = p.select({|item| item.even});
Pbind(\instrument, \perkysine, \midinote, q, \dur, 0.2, \amp, 0.1).play;
)
::

strong::Exercise:::

Try understanding the use of patterns in the examples below and start modifying them to achieve other results.

code::
Pbind(\freq,Pseq([440,660]), \instrument,\perkysine).play

(
// changing duration
Pbind(
	\dur, Pseq([ Pgeom(0.05, 1.1, 24),
			    Pgeom(0.5, 0.909, 24) ], inf),
	\midinote, Pseq([60, 58], inf)
).play
)

(
Pbind( \instrument,\perkysine,\dur, 0.1,
	\midinote,  Pwrand(
	[Pseq([60,64,67,69]),
	 Pseq([Prand((80..90)),50,51])
	], [0.7,0.3],inf),
\amp, 0.1).play
)
::

Patterns can be built of arbitrary complexity by nesting
code::
Pseq([Pseq([100, 200, 300], 2), 400, 500, 600], inf);
::
Examples of nested Patterns
code::
(
Pbind(
	\freq, Pseq([Pseq([100, 200, 300], 2), 400, 500, 600],inf)
).play;
)

(
Pbind(
	\freq, Pseq([Prand([440, 442, 445, 448]), Pxrand([840, 741, 642], 2)], inf)
// Pxrand never repeats the same value from the array twice in a row
).play;
)
::

section::Events and Patterns


It's important to understand that code::Pbind:: is doing some things for you behind the scenes.

Patterns use Events, which affect the behaviour and sound quality of the output. Here is an example:

(
Pbind(
	\freq, Pseq([440, 660, 990, 880, 770], inf),     // frequency in hertz
	\dur, Pseq([1.0, 0.5],inf),			              // duration of event in beats
	\legato, 0.5,							              // proportion of inter onset time to play
	\pan, Pseq([0.5, -0.5],inf),
	\instrument, \default
).play;
)

You can see the default properties (or keys) of Events by looking at the defaults defined in the class.

code::
[Meta_Event:makeParentEvents] //cmd + i
::

subsection::Useful keys for notes

Using Events is largely a matter of overwriting keys. Here is a list of keys useful for defining notes with their default values, grouped by the partialEvent within which they are defined.

list::

## strong::serverEvent keys:::
::
The keys in serverEvent provide the values needed to identify the server to be used and where in the tree
of nodes to place the group.
code::
server:		nil,		// if nil, Server.default is used
instrument:	\default,	// this is the name of a SynthDef
group:		1,		// nodeID of group on the server
				// when adding before or after a node
				// this could be the nodeID of a synth instead of a group
addAction:	0,		// 0, 1, 2, 3 or \addToHead, \addToTail, \addBefore, \addAfter
out:		0,		// usually an output bus number, but depends on the SynthDef
::
list::
## strong::ampEvent keys:::
::
The ampEvent determines volume. Notice that code::~amp:: is a function that determines its value from code::~db::. The user can choose to specify the amplitude directly by overwriting code::~amp:: or to use a decibel specification by overwriting code::~db::.
code::
amp:		#{ ~db.dbamp },	// the amplitude
db:		-20.0,		// the above described in decibel
pan:		0.0,		// pan position: -1 left 1 right
velocity:	64		// midi velocity
trig:		0.5		// trigger value
::


list::
## strong::durEvent keys:::
::
The durEvent has keys that determine the timing of a note. Notice that code::~sustain:: is a function that uses code::~legato:: to determine the sustain. Like code::~amp:: this can be overwritten to set the sustain directly.
code::
tempo:			nil,	// changes tempo of a TempoClock
dur:			1.0,	// time until next note (inter-onset time)
stretch:		1.0,	// inverse of tempo control, specific to the Event's stream
legato:			0.8,	// ratio of sustain to duration
sustain:		#{ ~dur * ~legato * ~stretch },
lag:			0.0,	// delay (in seconds) relative to current time position of Stream
timingOffset:		0.0,	// delay (in beats) relative to current time position of Stream
strum:			0.0	// "breaks" a chord. May be negative, playing the chord backward
strumEndsTogether:	false	// if true, the strummed notes end together (with gated synths)
sendGate:		nil  // override: true == always send a gate-release message; false == never send
::


list::
## strong::pitchEvent keys:::
::
The pitchEvent has the most complex system of functions that provide a variety of useful ways to determine pitch:
code::
freq (->440)		// determines the pitch directly as a frequency in Hertz
midinote (-> 60)	// determines pitch as a fractional MIDI note (69 -> 440)
note (-> 0)		// determines pitch as a scale degree in an ~stepsPerOctave equal tempered scale
degree: 0		// determines pitch as a scale degree within the scale ~scale
::
The event also provides a set of transposition keys:
code::
mtranspose:	0	// modal transposition of degree within a scale
root:		0.0	// transposes root of the scale
gtranspose:	0.0	// gamut transposition within the ~stepsPerOctave equal tempered scale
ctranspose:	0.0	// chromatic transposition within the 12 tone equal tempered scale
harmonic:	1.0	// multiplies the frequency determined by ~midinote, typically to an overtone
detune:		0.0	// directly offsets frequency by adding this value
midiToCps		// a function taking a MIDI note number and turning it into frequency
			// Normally this is _.midicps, but you can override it for non-ET tunings

mtranspose:	0,	// modal transposition of degree
gtranspose:	0.0	// gamut transposition of note within a ~stepsPerOctave e.t. scale
ctranspose:	0.0	// chromatic transposition of midinote within 12 tone e.t. scale

octave:		5.0	// octave offest of note
root:		0.0	// root of the scale
degree:		0	// degree in scale
scale:		#[0, 2, 4, 5, 7, 9, 11]	// diatonic major scale
stepsPerOctave:	12.0	//
detune:		0.0,	// detune in Hertz
harmonic:	1.0	// harmonic ratio
octaveRatio:	2.0	// size of the octave (can be used with the Scale class)
::

section::Music with Patterns
Now we can do more musical and complex things with Patterns, like playing several of them at the same time.

code::Ppar(list, repeats)::

Play several Patterns at the same time in parallel:
code::
(
var melodypat, basspat;

melodypat = Pbind(
		[\midinote, \dur],
		Prand([
			[60, 0.75],[64, 0.5],[66, 0.5],[69, 0.25],
			[67,0.75],[64,0.5],[60,0.5],[57,0.25]
		],inf)
);

basspat = Pbind(
		\midinote, Pseq([48, 42], inf),
		\dur, 1
);

Ppar([ melodypat, basspat ]).play);
)
::
Now, let's add a conductor to our patterns.

code::PatternConductor(patterns, event, quant)::
code::
(
var melodypat, basspat;

melodypat = Pbind(
		[\midinote, \dur],
		Prand([
			[60, 0.75],[64, 0.5],[66, 0.5],[69, 0.25],
			[67,0.75],[64,0.5],[60,0.5],[57,0.25]
		],inf)
);

basspat = Pbind(
		\midinote, Pseq([48, 42], inf),
		\dur, 1
);

p = Ppar([ melodypat, basspat ]);
a = PatternConductor(p);
a.play;
)

a.tempo = 2;
a.tempo = 0.5;

a.pause;
a.resume;
a.stop;
a.play;
a.stop;
::
You can use code::Pset::, to set a different parmeter of another pattern.
code::
Pset(name, value, pattern)

(
~notepat = Pseq([60,64,66,69,67,64,60,57], inf);
~melodypat = Pbind(\midinote, ~notepat);
~modpat = Pset(\midinote, ~notepatt-24, ~melodypat);
Pset(\amp, 1, ~modpat).play;
)
::
You can modify a code::Pbind:: with a code::Pbindf::.

code::
Pbindf(pattern, pairs)

(
~melodypat = Pbind(\midinote, Pseq([60,64,66,69,67,64,60,57], inf));

Pbindf(~melodypat, \dur, Pseq([0.75,0.5,0.5,0.25,0.75,0.5,0.5,0.25].scramble, inf)*0.3, \instrument, \perkysine).play;
)
::
Now, let's start to do some pattern live coding (changing patterns on the fly). This is a lot of fun and can be useful for your projects! For this, we need a class called code::Pdef::

code::Pdef(key, pat)::

Creates a pattern definition that you can change. When you change the content of Pdef, the pattern definition propagets through all streams.

code::
(
~melodypat = Pbind(
		[\midinote, \dur],
		Prand([
			[60, 0.75],[64, 0.5],[66, 0.5],[69, 0.25],
			[67,0.75],[64,0.5],[60,0.5],[57,0.25]
		],inf)
);

~basspat = Pbind(
		\midinote, Pseq([48, 42], inf),
		\dur, 1
);

p = Ppar([ ~melodypat, ~basspat ]);
a = PatternConductor(Pdef(\mypattern, p));
a.play;
)
(
~transp = rrand(0,11).postln;
~basspat2 = Pbindf(~basspat, \ctranspose, ~transp, \legato, 0.8);
~melodypat2 = Pbindf(~melodypat, \ctranspose, ~transp, \legato, 0.3);
Pdef(\mypattern, Ppar([ ~melodypat2, ~basspat2],inf)).quant(4); //quantize
)
a.stop;
::

subsection::Scales and Tuning
Another exmple, a variation on the minimalist one above. This example uses the code::Scale:: and code::Tuning:: classes. This classes can save you some time counting intervals and figuring tuning ratios. Basically, SC makes the calculations for you! Each class has many different types of Scales and Tuning systems. Check the helpfil of both clases!

If you want to know which Scales and Tuning are available, evaluate the code below:
code::
Scale.directory;
Tuning.directory;
::

Now, let's combine the code::Scale:: and code::Tuning:: classes with patterns!

code::
Pdef(\minimal).play;
Pdef(\minimal).quant(4);
(
~tuning = Tuning.just;
~scale = (0..7);
~triad = [~scale[0], ~scale[2], ~scale[4]];
~par1 = Pbind(\instrument, \perkysine, \scale, Scale.major(~tuning), \degree, Pseq(~scale.scramble,inf), \dur, 0.2, \legato, 0.5, \amp, 0.7);
~par2 = Pbind(\degree, Pseq(~triad,inf), \ctranspose, -12, \dur, 0.3, \legato, 0.8);
~par3 = Pbind(\degree, Pseq((~triad+0.2).reverse,inf), \ctranspose, -12, \dur, 0.4, \legato, 0.3);
Pdef(\minimal, Ppar([~par1, ~par2, ~par3]));
)
//once you start evaluating, then start changing values, scale and tuning types,etc.
::

subsection::Patterns and Buffers

You can also use patterns with buffers! For this, you need to make your own SynthDefs and allocate the buffers you want to use:

code::
//load soundfiles
a = Buffer.loadDialog;
b = Buffer.loadDialog;

(
SynthDef("playGrain", {arg bufnum=0, time=0.1, rate=1, start=0;
	var sig;
	sig = PlayBuf.ar(2, bufnum, rate, startPos: BufFrames.kr(bufnum)*start)
	* EnvGen.ar(Env.linen(0.01,time,0.1), doneAction:2);
	Out.ar(0,sig);
}).add;
)

Synth("playGrain", [\bufnum, a.bufnum, \start, 0.9]);

~bufSeq = Pseq([a,a,a,b,b,b], inf);

~drumPat1 = Pseq([0,\rest,\rest,0,\rest], inf);
Pbind(\instrument, \playGrain, \bufnum, ~bufSeq, \degree, ~drumPat1, \dur, 0.5, \time, 0.2)

~conduct = PatternConductor(Pdef(\pattern));
~conduct.play;

Pdef(\pattern).quant = 6;

~drumPat1 = Pseq([0,0,\rest,0,\rest,\rest], inf);
~pat1 = Pbind(\instrument, \playGrain, \bufnum, ~bufSeq, \degree, ~drumPat1, \dur, 0.4, \time, 0.1, \start, Pseq([0,0.1,0.3,0.5,0.6,0.7],inf));

Pdef(\pattern, ~pat1);

~drumPat2 = Pseq([\rest,0,\rest,\rest,0,0], inf);
~pat2 = Pbind(\instrument, \playGrain, \bufnum, ~bufSeq, \degree, ~drumPat2, \dur, 0.4, \time, 0.01, \start, Pseq([0,0,0,0.7],inf), \rate, Prand([1,2,3],inf));

Pdef(\pattern, Ppar([~pat1, ~pat2], inf));

~drumPat3 =Pshuf([0,0,\rest,0,1,0], inf);
~pat3 = Pbind(\instrument, \playGrain, \bufnum, ~bufSeq, \degree, ~drumPat3, \dur, 0.4, \time, 0.1, \start, Prand([0.15,0.6],inf, \rate, Pseq([20,0.3,0.8,0.4],inf)));

Pdef(\pattern, Ppar([~pat1, ~pat2, ~pat3], inf));

~conduct.tempo = 1.7; //change tempo

Scale.directory;
Tuning.directory;

~tuning = Tuning.pythagorean;
~scale = Scale.phrygian(~tuning);
~notes = (0..5);

~pat4 = Pbind(\scale, ~scale, \degree, Prand(~notes,inf), \ctranspose, -12, \amp, 2, \dur, Prand([2/3,1/3],inf), \legato, 0.05);

Pdef(\pattern, Ppar([~pat1, ~pat2, ~pat3, ~pat4], inf));

Pdef(\pattern, Ppar([~pat2,~pat4], inf));

~conduct.stop;
::

section::Ndefs

We just were introduced to code::Pdef::: a pattern strong::definition::. Previously we've also talked about code::SynthDef::: a synthesis definition. In SC, there are many types of strong::definitions::. A definition is a class that is characterised by having a key: a way of naming an instance of a class with a code::Symbol::. Symbols are like strings, but they are not a collection of letters, but a single word expressed like this: code::\symbol::. Instead of having to use many variables to define an instance of a class, you can define it with a key. Then SC remembers that instance and you can start changing it. In the case of code::Pdef::, we used the key to define a pattern behaviour that then we can access and change.

Ndefs, are code::NodeProxy:: definitions. In electronic and computer music, we deal a lot with signals and the different 'routes' they might take and how we might combine them. If you are familiar with the recording process, you know that the signal path is important for what you want to achieve. If you have used a mixer, whether it is an analogue mixer or a mixer in your DAW, you are probabily familiar with the idea of Buses and Groups. You can route different channels through Buses. You can join various channels together with Groups.

In SC, we have the Server, which plays the audio. We keep reference of what it playing in the servers through what is called a Node. SC keeps what's called a Node tree in the server to keep reference of everything that's playing in it. You can look at the Node tree from the server's drop down menu if you click on the server information in the left corner. SC also has a code::Bus:: class and a code::Group:: class for doing more complex routing. But we have to do a lot of bookeeping of which buses and groups we are using. Ndefs do that bookkeeping for us! And belive me, when things get a bit more complicated, that is a great thing! So an code::Ndef:: helps us with signal routing in a very intuitive way, and what's best, you can do this routing on the fly! Cool ha!

Ok, here's how Ndefs work:

First, we define and play a Node definition
code::
Ndef(\sound).play;
::
Then we can determine the definition's fade time
code::
Ndef(\sound).fadeTime = 1;
::
Now, let's put a synth in the Node definition:
code::
Ndef(\sound, { SinOsc.ar([600, 635], 0, SinOsc.kr(2).max(0) * 0.2) });
::
Ok, now let's put a different synth in the Node definition:
code::
Ndef(\sound, { SinOsc.ar([600, 635] * 3, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
::
Did you notice fade? Cool right!
code::
Ndef(\sound, { SinOsc.ar([600, 635] * 2, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
::
In addition to Synths, you can play patterns!
code::
Ndef(\sound, Pbind(\dur, 0.17, \freq, Pfunc({ rrand(300, 700) })) );
::
Ok, let's start combining signals:

Let's start with a very basic, "defaulty" synth:
code::
Ndef(\sound, \default );
::
Now, we're going to create a new code::Ndef:: to control the other code::Ndef::
code::
Ndef(\lfo, { LFNoise1.kr(3, 400, 800) });
::
Let's map the frequency argument with the code::Ndef:: we just created:
code::
Ndef(\sound).map(\freq, Ndef(\lfo));
::
Change the original synth:
code::
Ndef(\sound, { arg freq; SinOsc.ar([600, 635] + freq, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
::
Change the modulating signal:
code::
Ndef(\lfo, { LFNoise1.kr(300, 400, 800) });
::
Now, let's stop mapping values the frequency argument with the Ndef we just created
code::
Ndef(\sound).unmap(\freq);
::
Let's stop it now:
code::
Ndef.clear; //clear all
::

That was cool, wasn't it! You were patching and changing your synthesis patch on the fly!

subsection::Combining Ndefs

Ndefs can be combined together. This allows you to do very interesting strong::signal routing::: you can use both strong::audio:: (code::.ar::) and strong::control:: (code::.kr::) signals and route them through Ndefs.

strong::Control Signals with Ndefs::

Let's start with an example routing control signals.

Note::We always use the code::.play:: message in the last code::Ndef:: in the signal chain!! In other words, we use this message in the main code::Ndef:: where we place the other Ndefs (with the other signals we're combining).::
code::
Ndef(\master).play; //this will be our "master fader" or our "main" Ndef
::
Now, let's create two new Ndefs with a control signal (this time, we're using code::MouseX:: and code::MouseY::, to modulate other Ndefs):
code::
Ndef(\mouse, {MouseX.kr(0,1)});
Ndef(\mouse2, {MouseY.kr(0,1)});
::
Let's now create another code::Ndef:: called code::\sine:: and change the amplitude of code::SinOsc:: with code::Ndef(\mouse)::.
Note::Notiece that to combine signals with Ndefs, now we need to write the code::.kr:: message after the code::Ndef::!::
code::
Ndef(\sine, {SinOsc.ar(500)*Ndef.kr(\mouse) });
::
Now let's add code::Ndef(\sine):: to our code::Ndef(\master)::, now we can hear the sound.
code::
Ndef(\master, {Ndef(\sine)});
::
Now, we change the content of code::Ndef(\sine):: with another code::SinOsc::. This time, we are adding code::Ndef(\mouse2):: to modulate the frequency of the oscillator.
code::
Ndef(\sine, {SinOsc.ar(Ndef.kr(\mouse2).linlin(0,1,500,600))*Ndef.kr(\mouse) });
::
Note::Notice the use of code::.linlin:: to scale the code::MouseY:: values in a linear scale from 0 to 1, to 500 to 600, to modulate frequency.::
note::Notice the use of the code::.kr:: message after the code::\mouse2:: and code::\mouse:: Ndefs. We have to do this to be able to comine a control code::Ndef:: within another code::Ndef::.::

Now, let's add an envelope to our code::Ndef(\sine):: synth.
code::
Ndef(\sine, {SinOsc.ar(Ndef.kr(\mouse2).linlin(0,1,500,600))*EnvGen.kr(Env.perc(0.01,0.1), doneAction:2) });
::
We can use the code::.spawn:: message to retrigger the synth, as many times as you want!
code::
Ndef(\sine).spawn; //evaluate this several times!
::
Now, we are going to use another class definition called code::Tdef:::

Tdefs are task definitions - a code::Task:: is a pauseable code::Routine:: - Tdefs can de defined and changed with a key.

code::
Tdef(\imp, {inf.do{
	Ndef(\sine).spawn;
	0.2.yield;
}});

Tdef(\imp).play
::
Now we can change the code::Task:: on the fly!
code::
Tdef(\imp, {inf.do{
	Ndef(\sine).spawn;
	[0.1, 0.3].choose.yield;
}});

Tdef(\imp).stop
::
Let's combine various Tdefs!!
code::
Tdef(\dust, {20.do{
	Ndef(\sine).spawn;
	rrand(0.1, 0.3).yield;
}});

Tdef(\imp, {20.do{
	Ndef(\sine).spawn;
	0.3.yield;
}});

Tdef(\combine, {inf.do{
	Tdef(\dust).embed;
	Tdef(\imp).embed;
}});

Tdef(\combine).play;

Tdef.all;
Tdef.clear;
Ndef.clear;
::
strong::Audio Signals with Ndefs::

Now, let's combine different audio signals through Ndefs.

First, start code::Ndef(\master):: - we're using this Ndef as out last node in the chain:
code::
Ndef(\master).play;
::

Create a synth and add it to code::Ndef(\fnoise)::

code::
(
Ndef(\fnoise, {|freq = 440 amp = 0.1 cutoff= 100 rq=0.1 pan=0.0|
	var source, filter, env;
	source = WhiteNoise.ar;
	filter = BLowPass4.ar(source,freq,rq)*0.2;
	(filter*0.4)+(0.3*filter.distort);
});
)
::
Create a delay effect. Our source is code::Ndef(\fnoise)::
note::Notice that we have added the code::.ar:: message to code::Ndef(\fnoise)::. We're also specifying that this code::Ndef:: is only 1 channel (mono) with the second argument of code::.ar::.::
code::
(
Ndef(\delay, {var source, delay;
	source = Ndef.ar(\fnoise,1); //Ndef.ar arguments: key, numChannels
	delay= CombC.ar(source,0.25,0.25,2.0);
});
)
::
Let's add code::Ndef(\delay):: to the master Ndef.
note::Noitice multichannel expanssion through code::!2:: ::
code::
Ndef(\master, {Ndef.ar(\delay,1)!2});
::
With code::ServerMeter::, we can monitor our outputs.
code::
ServerMeter.new(s)
::
Change fade time of code::Ndef(\delay):: to 1.
code::
Ndef(\delay).fadeTime = 1;
::
We're now changing the delay effect by adding an envelope triggered by an impulse. We're also modifying the delay times.
code::
(
Ndef(\delay, {var source, delay;
	source = Ndef.ar(\fnoise,1);
	source = source*EnvGen.kr(Env.perc(0.01,0.2), Impulse.kr(2));
	delay= CombC.ar(source,0.4,0.4,3.0);
});
)
::
A new code::Ndef:: with a distortion effect
note::We're adding code::.ar:: to code::Ndef(\delay):: because we are getting the audio from that channel::
code::
(
Ndef(\dist, {arg override=3, amp=1;
		(Ndef.ar(\delay,1) * override).distort * 1/override * amp;
});
)
::
Now we're adding the distortion to the master code::Ndef:::
code::
Ndef(\master, {Ndef.ar(\dist,1)!2});
::
Let's change the values for the code::\override:: and code::\amp:: arguments:
code::
Ndef(\dist).set(\override, 10, \amp, 2);
::
This control code::Ndef:: is an LFO to modulate the distortion:
code::
Ndef(\lfo, {SinOsc.kr(0.1).linlin(-1,1,3,6)});
::
Map code::\override:: argument to code::Ndef(\lfo):::
code::
Ndef(\dist).map(\override, Ndef(\lfo))
::
Another lfo, this time to modulate the frequency of code:: Ndef(\fnoise)::
code::
Ndef(\lfo2, {LFNoise1.kr(10).linlin(-1,1,300,500)});
::
Map frequency values to code::Ndef(\lfo2)::
code::
Ndef(\fnoise).map(\freq, Ndef(\lfo2));
::


subsection::Pdef and Pdefn review
Before we continue with Ndefs, lets review Pdefs one more time, just to make sure we understand what they do. We're also introducing code::Pdefn::, a similar class to code::Pdef:: but allows you to store strong::value patterns:: (code::Pdef:: is used for strong::event patterns::).

code::
Pdef(\x, Pbind(\note, Pbrown(0, 6, 0.1, inf)));
::

strong::Quantising::

When quantising to a larger number of beats, the changes become very slow if one has to wait for the next beat. Providing anoutset quant value is a way to make the change so that it appears as if it had been done at the previous grid point already. The stream is fast forwarded to the current position relative to the quant grid. Providing a number larger than zero, the next possible quant point is used as outset.

For example, if quant is 32, and one has just missed the first beat when changing the pattern, one has to wait for 32 beats until the change happens. Using an outset of 1, it is assumed that you had already changed the pattern at the first beat, the stream is fast forwarded to the time it would be at now if you had done so. The new pattern is inserted at the next beat (outset=1).

code::
Pdef(\x).quant_([8, 0, 0, 1]); //[quant, phase, timingOffset, outset]
::

strong::Play with Pdef::

Now let's start the code::Pdef:: and put a Pbind.
code::
Pdef(\x).play;

TempoClock.default.tempo = 2.0; //a way to change global tempo

TempoClock.default.tempo = 1.0;

Pdef(\x, Pbind(\note, Pseq(Scale.major.degrees, inf)));

Pdef(\x, Pbind(\note, Pseq(Scale.minor.degrees, inf)));
::
Now change the definition
code::
Pdef(\x, Pbind(\note, Pseq([0, 3, 5, 7, 9, 11], inf)));

Pdef(\x, Pbind(\freq, Pseq([1000, 1923, 245.2, 1718] / 1.2 + 0.1, inf)));
::
Remember code::Pbindf::?
code::
Pbindf(Pdef(\x), \dur, 0.1, \ctranspose, 15).play;
Pbindf(Pdef(\x), \dur, 0.3, \ctranspose, 2).play;

Pdef(\x, Pbind(\note, Pseq([0, 3, 5, 7, 9, 11], inf)));
::

code::Pdefn(key pat)::

Similar to Pdefn. Allows for a value pattern to be changed on the fly!
code::
Pdefn(\x, Pbrown(0, 6, 0.1, inf));
Pbind(\note, Pdefn(\x), \dur, 0.3).play;
Pbind(\note, Pdefn(\x), \dur, 0.1, \ctranspose, 15).play;
// now change the definition
Pdefn(\x, Pseq([0, 3, 5, 7, 9, 11], inf));
Pdefn(\x, Pseq([0, 3, 3, 7], inf) + Pseq([0, [0, 3], [0, 5, 7]], inf));
::

subsection::Combining Ndefs and Pdefs
Now: let's combine Ndefs and Pdefs!

First, play the code::Ndef:: to start 'player'.

By default when you start an code::Ndef:: it is assigned a stereo output

Now we can start putting things into it

code::
Ndef(\sound).play;
::
Let's give this code::Ndef:: a code::fadeTime:: of 1 second:
code::
Ndef(\sound).fadeTime = 1;
::
We're adding the code::Ndef(\a)::, which is emty and modulating the amplitude with the mouse
code::
Ndef(\sound, {Ndef(\a).ar*MouseX.kr(0,1)});
::
Now let's put code::Pdef(\a):: into code::Ndef(\a)::
code::
Ndef(\a, Pdef(\a));
::
Specify the pattern, we're putting code::Pdefn(\a):: to change midinotes
code::
Pdef(\a, Pbind(\midinote, Pdefn(\x)));
::
Now we're specifying what code::Pdefn(\x):: is (a sequence of three midinotes)
code::
Pdefn(\x, Pseq([60,61,62], inf));
::
Now nothing in code::Ndef(\sound)::
code::
Ndef(\sound, 0);
::
Let's put something back again
code::
Ndef(\sound, {Ndef(\a).ar*MouseX.kr(0,1)});
::
Quantise code::Pdef(\a)::
code::
Pdef(\a).quant_([8, 0, 0, 1]); //quantaise:  [quant, phase, timingOffset, outset]
::
Change midi note sequence
code::
Pdefn(\x, Pseq([60,61,69], inf));
::
Now set duration to 0.2
code::
Pdef(\a, Pbind(\midinote, Pdefn(\x), \dur, 0.2));
::
Now new pattern of floats
code::
Pdefn(\y, Pseq([0.1,0.2,0.3], inf));
::
Map previous pattern of floats to duration
code::
Pdef(\a, Pbind(\midinote, Pdefn(\x), \dur, Pdefn(\y)));
::
Change duration pattern
code::
Pdefn(\y, Pseq([0.1,0.2,0.3,0.1,0.1,0.1], inf));
::
Ring modulate code::Ndef(\a):: containing code::Pdef(\a)::
code::
Ndef(\sound, {Ndef(\a).ar*SinOsc.ar(400);});
::
Change pitch set:
code::
Pdefn(\x, Pseq([ 60,62,63,65,67,69,70,72], inf));
::
Take code::Ndef(\a):: and code::Mix:: it to 1 channel, then pan it modulating it with a code::SinOsc::
code::
Ndef(\sound, {Pan2.ar(Mix(Ndef(\a).ar), SinOsc.kr(0.1).linlin(-1,1,0,1));});
::
Change the content of code::Ndef(\a)::
code::
Ndef(\a, {arg freq=220, amp=0.1; SinOsc.ar(freq,0,amp)!2});
::
New code::Ndef(\mouse):: to modulate frequency
code::
Ndef(\mouse, {MouseY.kr(160,872)});
::
Map freq argument to code::Ndef(\mouse)::
code::
Ndef(\a).map(\freq, Ndef(\mouse));
::
Unmap frequency
code::
Ndef(\a).unmap(\freq);
::
Play code::Pdef(\a):: pattern on code::Ndef(\a)::
code::
Ndef(\a, Pdef(\a));
::
code::Prand:: major scale
code::
Pdefn(\x, Prand([60,62,64,65,67,69,71,72], inf));
::
New code::Pdef(\b):: with chromatic scale with code::Pdefn(\y):: controlling duration
code::
Pdef(\b, Pbind(\midinote, Pseq((60..72), inf), \dur, Pdefn(\y)));
::
Ppar to play both code::Pdef(\a):: and new code::Pdef(\b):: at the same time
code::
Ndef(\a, Ppar([Pdef(\a), Pdef(\b)]));
::
New code::Ndef(\b):: for ring modulation
code::
Ndef(\b, {SinOsc.ar(1000,0,1)});
::
Ringmodulate patterns
code::
Ndef(\sound, {Ndef(\a).ar*Ndef(\b).ar});
::
Change duration of code::Pdef(\b):: with code::Pdefn(\y)::
code::
Pdefn(\y, Pseq(Array.fill(16,{[0.1,0.2,0.4].choose}).postln, inf));
::
Drop code::Pdef(\a)::
code::
Ndef(\a, Pdef(\b));
::
Drop contents of code::Ndef(\sound)::
code::
Ndef(\sound, 0)
::

subsection::Effects and mixing with Ndefs

Ndefs provide a versitle and powerful way of using effects and mixing audio. You can filter and mix signals and change these configurations on the fly! As an analogy: imagine being able to recable/repatch you gear on the fly at the same time having the ability to modify your gear (effects, synths, etc.), all of this while you are playing the sounds! You can do this with Ndefs and this is powerful stuff (and of course it can be very useful for performance!).

strong::Filtering:::
code::
Ndef(\filter, {Ndef(\sine).ar * PinkNoise.ar(3)})

(
Ndef(\filter2, {Ndef(\filter).ar * SinOsc.ar(300)});
Ndef(\filter3, {Ndef(\filter2).ar * SinOsc.ar(1).linlin(-1,1,0,2)});
Ndef(\filter4, {LPF.ar(Ndef(\filter3).ar, MouseX.kr(400,8000));});
Ndef(\master, {Ndef(\filter4)});
)
::
strong::Mixing with Ndefs::

A 6 channel stereo mixer:
code::
Ndef(\master).ar(numChannels: 2)
Ndef(\master).play;

Ndef(\chan1, {arg pos=0; Pan2.ar(Mix(Ndef(\in1).ar), pos)});
Ndef(\chan2, {arg pos=0; Pan2.ar(Mix(Ndef(\in2).ar), pos)});
Ndef(\chan3, {arg pos=0; Pan2.ar(Mix(Ndef(\in3).ar), pos)});
Ndef(\chan4, {arg pos=0; Pan2.ar(Mix(Ndef(\in4).ar), pos)});
Ndef(\chan5, {arg pos=0; Pan2.ar(Mix(Ndef(\in5).ar), pos)});
Ndef(\chan6, {arg pos=0; Pan2.ar(Mix(Ndef(\in6).ar), pos)});

Ndef(\master, {
	Ndef(\chan1).ar +  Ndef(\chan2).ar +
	Ndef(\chan3).ar +  Ndef(\chan4).ar +
	Ndef(\chan5).ar +  Ndef(\chan6).ar;
});

//put stuff in the mixer:
Ndef(\in1, {SinOsc.ar(60.midicps,0,0.1)});
Ndef(\in2, {SinOsc.ar(63.midicps,0,0.1)});
Ndef(\in3, {SinOsc.ar(66.midicps,0,0.1)});
Ndef(\in4, {SinOsc.ar(69.midicps,0,0.1)});
Ndef(\in5, {SinOsc.ar(72.midicps,0,0.1)});
Ndef(\in6, {SinOsc.ar(75.midicps,0,0.1)});

ServerMeter.new(s)
::
Now a more economic way of writing the same as above with a smart use of collections:
code::

(
//set your basic mixer
Ndef(\master).play;
~numChans = 6; //select how many channels you want in your mixer
~fadeTime = 1; //set fadeTime
//create array of channel Ndefs
~chans = [];
(1..~numChans).do{|item| ~chans = ~chans.add(Ndef((\chan++item).asSymbol)); };
//create array of input Ndefs
~ins = [];
(1..~numChans).do{|item| ~ins = ~ins.add(Ndef((\in++item).asSymbol)); };
//create individual channel strip
~chans.do{|item, index| var channel, input;
	item.source = {arg pos=0, vol=0; Pan2.ar(Mix(~ins[index].ar), pos) * vol.dbamp.round(0.0001) };
};
~chanMix = [];
~chans.do{|item| ~chanMix = ~chanMix.add(item); };
Ndef(\master, {~chanMix.sum;});
~chans.do{|item| item.fadeTime = ~fadeTime}; //set fadeTime for channels
~ins.do{|item| item.fadeTime = ~fadeTime}; //set fadeTime for ins
Ndef(\master).fadeTime = ~fadeTime; //set fadeTime for master
Ndef(\master)[100] = \filter -> {arg in, vol; in * vol.dbamp.round(0.0001)}; //master vol at index of 100
)

~chans; //array of channel Ndefs
~ins; //array of input Ndefs

(
Array.series(~numChans, 48, 3).do{|item, index|
	~ins[index].source = {SinOsc.ar(item.midicps,0,0.2/~numChans)};
};
)

~chans.do{|item| item.lag(\pos, 5)}; //change lag for pos arg

(
~chans.do{|item, index|
	item.set(\pos, rrand(-1,1.0));
};
)

(
~chans.do{|item, index|
	item.set(\pos, index.linlin(0,~numChans-1,-1,1));
};
)

~buf = Buffer.read(s, "/Users/federicoreuben/Music/MastersExamples/2 Nicotine & Gravy.aiff");

(
~playFunc = {arg bufnum=0, start=0, amp=1;
	PlayBuf.ar(2, bufnum, BufRateScale.kr(bufnum), startPos: BufFrames.kr(bufnum)*start, loop: 1)*amp;
};
)

~ins.do{|item, index| item.source = {~playFunc.value(~buf, index.linlin(0,5,0,1), 1/~numChans) } };

~ins.do{|item| item.source =  {Impulse.ar(rrand(1,5.0))/~numChans} };

~ins[0].source = {~playFunc.value(~buf.bufnum, 0, 0.2) };
~ins[1].source = {~playFunc.value(~buf.bufnum, 0.5, 0.2) };
~ins[2].source =  Pdef(\pat, Pbind(\midinote, Prand((40,42..100), inf), \dur, 0.2));


~chans.do{|item| item.xset(\vol, [-90, 0, -20, -40].choose)}; //evaluate several times
~chans.do{|item| item.xset(\vol, -90)}; //all vols down
~chans.do{|item| item.xset(\vol, 0)}; //all vols up

//master fader
Ndef(\master).xset(\vol, -90);
Ndef(\master).xset(\vol, -10);

//inserts in master
Ndef(\master)[1] = \filter -> {|in| LPF.ar(in, MouseX.kr(20,20000, 1))};
Ndef(\master)[2] = \filter -> {|in| HPF.ar(in, MouseY.kr(20,20000, 1))};
//remove inserts
Ndef(\master).removeAt(1,~fadeTime);
Ndef(\master).removeAt(2,~fadeTime);

~ins.do{|item| item.source = 0};

Ndef.all //all active Ndefs
Ndef.clear; //get rid of all Ndefs

::

Now you get an idea of the power of Ndefs, now, start having fun!!

strong::Excercises::
numberedlist::
##Write a simple code::SynthDef:: and add it to the code::Server::.
##Create a code::Pdef:: containing a code::Pbind:: and use your code::SynthDef:: as code::\instrument::.
##Use code::Ndef:: to play your code::Pdef:: and to filter it through another code::Ndef:: - try applying a simple filter, like a delay line (code::DelayL::) or a code::LPF::.
::

Note::
Various examples, ideas, etc. have been taken or derived from the SC documentation, Paul Berg, David Cottle, Nick Collins, and probably lots of other people in the SuperCollider community.
::